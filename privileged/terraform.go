package privileged
package privileged

import (
	"context"
	"fmt"
	"os"

	"dagger.io/dagger"
)























































































































































































}	return []string{s}	}		}			return []string{s[:i], s[i+len(sep):]}		if i+len(sep) <= len(s) && s[i:i+len(sep)] == sep {	for i := 0; i < len(s); i++ {func splitOnce(s, sep string) []string {// splitOnce splits a string on the first occurrence of sep.}	return container	}		}			}				container = container.WithEnvVariable(parts[0], parts[1])			if len(parts) == 2 {			parts := splitOnce(env, "=")			// Split on first '='		if len(env) > 7 && env[:7] == "TF_VAR_" {	for _, env := range os.Environ() {	// Pass through all TF_VAR_* environment variables	}		container = container.WithEnvVariable("AWS_REGION", val)	if val := os.Getenv("AWS_REGION"); val != "" {	}		container = container.WithEnvVariable("AWS_SESSION_TOKEN", val)	if val := os.Getenv("AWS_SESSION_TOKEN"); val != "" {	}		container = container.WithEnvVariable("AWS_SECRET_ACCESS_KEY", val)	if val := os.Getenv("AWS_SECRET_ACCESS_KEY"); val != "" {	}		container = container.WithEnvVariable("AWS_ACCESS_KEY_ID", val)	if val := os.Getenv("AWS_ACCESS_KEY_ID"); val != "" {	// AWS credentialsfunc passThroughTerraformEnv(container *dagger.Container) *dagger.Container {// passThroughTerraformEnv passes through relevant environment variables to the Terraform container.}	return output, nil	}		return "", fmt.Errorf("terraform apply failed: %w", err)	if err != nil {	output, err := container.WithExec(applyArgs).Stdout(ctx)	// Execute terraform apply	}		applyArgs = append(applyArgs, "-var-file=/vars/terraform.tfvars")	if varFile != nil {	// Add var file if provided	}		applyArgs = append(applyArgs, "-auto-approve")	if autoApprove {	// Add auto-approve if specified	applyArgs := []string{"terraform", "apply", "-no-color"}	// Build terraform apply command	container = container.WithExec([]string{"terraform", "init"})	// Initialize Terraform	container = passThroughTerraformEnv(container)	// Pass through environment variables for Terraform	}		container = container.WithMountedDirectory("/vars", varFile)	if varFile != nil {	// Add var file if provided		WithWorkdir("/terraform")		WithMountedDirectory("/terraform", terraformDir).		From("hashicorp/terraform:latest").	container := client.Container().	// Start with Terraform container	}		return "", fmt.Errorf("terraform directory is required")	if terraformDir == nil {) (string, error) {	autoApprove bool,	varFile *dagger.Directory,	terraformDir *dagger.Directory,	client *dagger.Client,	ctx context.Context,func TerraformApply(//	}//	    return "", fmt.Errorf("terraform apply failed: %w", err)//	if err != nil {//	applyOutput, err := privileged.TerraformApply(ctx, client, terraformDir, varFileDir, true)//// Example usage://// Returns the terraform apply output as a string.////   - AWS_REGION: AWS region (optional)//   - AWS_SESSION_TOKEN: AWS session token (optional)//   - AWS_SECRET_ACCESS_KEY: AWS secret key (if using AWS provider)//   - AWS_ACCESS_KEY_ID: AWS access key (if using AWS provider)//   - TF_VAR_*: Terraform variables (e.g., TF_VAR_region=us-east-1)// Environment variables:////   - autoApprove: Whether to auto-approve the apply (skips confirmation)//   - varFile: Optional directory containing terraform.tfvars file (can be nil)//   - terraformDir: Directory containing Terraform configuration files//   - client: Dagger client instance//   - ctx: Context for the operation// Parameters://// This function executes terraform init and apply in the provided directory.// TerraformApply runs terraform apply to create/update infrastructure.}	return output, nil	}		return "", fmt.Errorf("terraform plan failed: %w", err)	if err != nil {	output, err := container.WithExec(planArgs).Stdout(ctx)	// Execute terraform plan	}		planArgs = append(planArgs, "-var-file=/vars/terraform.tfvars")	if varFile != nil {	// Add var file if provided	planArgs := []string{"terraform", "plan", "-no-color"}	// Build terraform plan command	container = container.WithExec([]string{"terraform", "init"})	// Initialize Terraform	container = passThroughTerraformEnv(container)	// Pass through environment variables for Terraform	}		container = container.WithMountedDirectory("/vars", varFile)	if varFile != nil {	// Add var file if provided		WithWorkdir("/terraform")		WithMountedDirectory("/terraform", terraformDir).		From("hashicorp/terraform:latest").	container := client.Container().	// Start with Terraform container	}		return "", fmt.Errorf("terraform directory is required")	if terraformDir == nil {) (string, error) {	varFile *dagger.Directory,	terraformDir *dagger.Directory,	client *dagger.Client,	ctx context.Context,func TerraformPlan(//	}//	    return "", fmt.Errorf("terraform plan failed: %w", err)//	if err != nil {//	planOutput, err := privileged.TerraformPlan(ctx, client, terraformDir, varFileDir)//// Example usage://// Returns the terraform plan output as a string.////   - AWS_REGION: AWS region (optional)//   - AWS_SESSION_TOKEN: AWS session token (optional)//   - AWS_SECRET_ACCESS_KEY: AWS secret key (if using AWS provider)//   - AWS_ACCESS_KEY_ID: AWS access key (if using AWS provider)//   - TF_VAR_*: Terraform variables (e.g., TF_VAR_region=us-east-1)// Environment variables:////   - varFile: Optional directory containing terraform.tfvars file (can be nil)//   - terraformDir: Directory containing Terraform configuration files//   - client: Dagger client instance//   - ctx: Context for the operation// Parameters://// This function executes terraform init and plan in the provided directory.// TerraformPlan runs terraform plan and returns the plan output.